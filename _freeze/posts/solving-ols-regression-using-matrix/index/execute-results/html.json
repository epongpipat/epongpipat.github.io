{
  "hash": "5d7b9b8f893e6caa32282c052f9e5f19",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Solving Ordinary Least Squares (OLS) Regression Using Matrix Algebra\"\ndate: \"2019-01-30\"\nformat:\n  html:\n    toc: true\n    toc-title: \"Table of Contents\"\n    toc-depth: 3\n    toc-location: left\n    number-sections: true\n    code-fold: show\n    warning: false\ncategories: [matrix algebra, R, statistics]\nimage: eq.png\n---\n\n\n\n\nIn psychology, we typically learn how to calculate OLS regression by calculating each coefficient separately. However, I recently learned how to calculate this using matrix algebra. Here is a brief tutorial on how to perform this using R.\n\n<br>\n\n## R Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackages <- c(\"tidyverse\", \"broom\")\nxfun::pkg_attach(packages, message = F)\n```\n:::\n\n\n\n<br>\n\n## Dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndataset <- carData::Salaries %>%\n  select(salary, yrs.since.phd) %>%\n  mutate(yrs.since.phd = scale(yrs.since.phd, center = T, scale = F))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(dataset)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     salary             yrs.since.phd.V1      \n Min.   : 57800   Min.   :-21.31486146100000  \n 1st Qu.: 91000   1st Qu.:-10.31486146100000  \n Median :107300   Median : -1.31486146096000  \n Mean   :113706   Mean   : -0.00000000000001  \n 3rd Qu.:134185   3rd Qu.:  9.68513853904000  \n Max.   :231545   Max.   : 33.68513853900000  \n```\n\n\n:::\n:::\n\n\n\nThe `Salaries` dataset is from the `carData` package, which shows the salary of professors in the US during the academic year of 2008 and 2009. Let's say we are interested in determining if professors who have had their Ph.D. degree for longer are more likely to also have higher salaries.\n\n<br>\n\n## Solve Using Matrix Algebra\n\n### Design Matrix ($X$)\n\nThe design matrix is just a dataset of the all the predictors, which includes the `intercept` set at 1 and `yrs.since.phd`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- tibble(\n  intercept = 1,\n  yrs.since.phd = as.numeric(dataset$yrs.since.phd)\n) %>%\n  as.matrix()\nhead(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     intercept yrs.since.phd\n[1,]         1     -3.314861\n[2,]         1     -2.314861\n[3,]         1    -18.314861\n[4,]         1     22.685139\n[5,]         1     17.685139\n[6,]         1    -16.314861\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n### Dependent Variable ($Y$)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- dataset$salary %>% as.matrix()\nhead(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       [,1]\n[1,] 139750\n[2,] 173200\n[3,]  79750\n[4,] 115000\n[5,] 141500\n[6,]  97000\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n### $X'X$\n\nFirst, we need to solve for $X'X$, which is the transposed design matrix ($X'$) multiplied by the design matrix ($X$). \n\nLet's take a look at what $X'$ looks like.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_transposed <- t(x)\nx_transposed[, 1:6]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   [,1]      [,2]      [,3]     [,4]     [,5]      [,6]\nintercept      1.000000  1.000000   1.00000  1.00000  1.00000   1.00000\nyrs.since.phd -3.314861 -2.314861 -18.31486 22.68514 17.68514 -16.31486\n```\n\n\n:::\n:::\n\n\n\n<br>\n\nAfter multiplication, the matrix provides the total number of participants ($n$ = 397; really, the sum of the intercept), sum of `yrs.since.phd` ($\\Sigma(yrs.since.phd)$ = 0), and sum of squared `yrs.since.phd` ($\\Sigma (yrs.since.phd^2)$ = 65765.64). Respectively, $\\Sigma (years.since.phd)$ and $\\Sigma (yrs.since.phd^2)$ are sum of error ($\\Sigma(yrs.since.phd-M_{yrs.since.phd})$) and sum of squared error ($\\Sigma(yrs.since.phd-M_{yrs.since.phd})^2$) because we first centered the `yrs.since.phd` variable.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_prime_x <- (x_transposed %*% x)\nx_prime_x %>% round(., 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              intercept yrs.since.phd\nintercept           397          0.00\nyrs.since.phd         0      65765.64\n```\n\n\n:::\n:::\n\n\n\n<br>\n\nLet's verify this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(x) %>% round(., 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    intercept yrs.since.phd \n          397             0 \n```\n\n\n:::\n\n```{.r .cell-code}\ncolSums(x^2) %>% round(., 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    intercept yrs.since.phd \n       397.00      65765.64 \n```\n\n\n:::\n:::\n\n\n\n<br>\n\n### $(X'X)^{-1}$\n\n$(X'X)^{-1}$ is the inverse matrix of $X'X$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_prime_x_inverse <- solve(x_prime_x)\nx_prime_x_inverse\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                 intercept yrs.since.phd\nintercept     2.518892e-03  9.280150e-20\nyrs.since.phd 9.280150e-20  1.520551e-05\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n### $X'Y$\n\n$X'Y$ contains the sum of Y ($\\Sigma Y$ = 45141464) and sum of $XY$ ($\\Sigma XY$ = 64801658).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_prime_y <- x_transposed %*% y\nx_prime_y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                  [,1]\nintercept     45141464\nyrs.since.phd 64801658\n```\n\n\n:::\n:::\n\n\n\n<br>\n\nLet's verify this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 45141464\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(x[, 2] * y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 64801658\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n### Coefficients ($B$)\n\nTo obtain the coefficients, we can multiply these last two matrices ($B = (X'X)^{-1}X'Y$).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoef <- x_prime_x_inverse %*% x_prime_y\ncoef\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     [,1]\nintercept     113706.4584\nyrs.since.phd    985.3421\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n### Standard Error\n\nTo calculate the standard error, we multiply the inverse matrix of $X'X$ by the mean squared error (MSE) of the model and take the square root of its diagonal matrix ($\\sqrt{diag((X'X)^{-1} * MSE)}$).\n\n<br>\n\nFirst, we need to calculate the $MSE$ of the model. Calculating $MSE$ of the model is still the same, $MSE = \\frac{\\Sigma(Y-\\hat{Y})^{2}}{n-p} = \\frac{\\Sigma(e^2)}{df}$ where $Y$ is the DV, $\\hat{Y}$ is the predicted DV, $n$ is the total number of participants (or data points), and $p$ is the total number of variables in the design matrix (or predictors, which includes the intercept). \n\n<br>\n\nTo obtain the predicted values ($\\hat{Y}$), we can also use matrix algebra by multiplying the design matrix with the coefficients ($\\hat{Y} = XB$).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny_predicted <- x %*% coef\nhead(y_predicted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          [,1]\n[1,] 110440.19\n[2,] 111425.53\n[3,]  95660.05\n[4,] 136059.08\n[5,] 131132.37\n[6,]  97630.74\n```\n\n\n:::\n:::\n\n\n\n<br>\n\nNow that we have $\\hat{Y}$, we can then calculate the $MSE$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne <- y - y_predicted\nse <- sum(e^2)\nn <- nrow(x)\np <- ncol(x)\ndf <- n - p\nmse <- se / df\nmse\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 758098328\n```\n\n\n:::\n:::\n\n\n\n<br>\n\nThen, we multiply $(X'X)^{-1}$ by MSE.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmse_coef <- x_prime_x_inverse * mse\nmse_coef %>% round(., 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              intercept yrs.since.phd\nintercept       1909568          0.00\nyrs.since.phd         0      11527.27\n```\n\n\n:::\n:::\n\n\n\n<br>\n\nThen, we take the square root of the diagonal matrix to obtain the standard error of the coefficients.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrmse_coef <- sqrt(diag(mse_coef))\nrmse_coef %>% round(., 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    intercept yrs.since.phd \n      1381.87        107.37 \n```\n\n\n:::\n:::\n\n\n\n<br>\n\n### *t*-Statistic\n\nThe *t*-statistic is just the coefficient divided by the standard error of the coefficient.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt_statistic <- as.numeric(coef) / as.numeric(rmse_coef)\nt_statistic\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 82.284421  9.177488\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n### *p*-Value\n\nWe want the probability of obtaining that score or more extreme and not the other way around. Thus, we need to set lower to FALSE. Also, we need to multiply it by 2 to obtain a two-tailed test.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_value <- 2 * pt(t_statistic, df, lower = FALSE)\np_value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.070665e-250  2.495042e-18\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n### Summary\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  term = colnames(x),\n  estimate = as.numeric(coef),\n  std.error = as.numeric(rmse_coef),\n  statistic = as.numeric(t_statistic),\n  p.value = as.numeric(p_value)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n  term          estimate std.error statistic   p.value\n  <chr>            <dbl>     <dbl>     <dbl>     <dbl>\n1 intercept      113706.     1382.     82.3  1.07e-250\n2 yrs.since.phd     985.      107.      9.18 2.50e- 18\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n## Solve Using `lm` Function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm(salary ~ yrs.since.phd, dataset) %>% tidy()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n  term          estimate std.error statistic   p.value\n  <chr>            <dbl>     <dbl>     <dbl>     <dbl>\n1 (Intercept)    113706.     1382.     82.3  1.07e-250\n2 yrs.since.phd     985.      107.      9.18 2.50e- 18\n```\n\n\n:::\n:::\n\n\n\n<!-- disqus START -->\n<br>\n\n<hr>\n\n<br>\n\n<div id=\"disqus_thread\"></div>\n<script>\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = 'https://ekarinpongpipat.com/blog-solving-ols-regression-using-matrix-algebra.html';  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = 'blog_solving_ols_regression_using_matrix_algebra'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = 'https://epongpipat.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();\n</script>\n<noscript>Please enable JavaScript to view the <a href=\"https://disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n<!-- disqus END -->",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}